{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import{useState as $11sjw$useState,useRef as $11sjw$useRef,useCallback as $11sjw$useCallback}from\"react\";function $parcel$export(e,n,v,s){Object.defineProperty(e,n,{get:v,set:s,enumerable:true,configurable:true});}var $bfee1151ccb0650f$exports={};$parcel$export($bfee1151ccb0650f$exports,\"useControlledState\",function(){return $bfee1151ccb0650f$export$40bfa8c7b0832715;});function $bfee1151ccb0650f$export$40bfa8c7b0832715(value1,defaultValue,onChange){var _$11sjw$useState=$11sjw$useState(value1||defaultValue),_$11sjw$useState2=_slicedToArray(_$11sjw$useState,2),stateValue=_$11sjw$useState2[0],setStateValue=_$11sjw$useState2[1];var ref=$11sjw$useRef(value1!==undefined);var wasControlled=ref.current;var isControlled=value1!==undefined;var stateRef=$11sjw$useRef(stateValue);if(wasControlled!==isControlled)console.warn(\"WARN: A component changed from \"+(wasControlled?'controlled':'uncontrolled')+\" to \"+(isControlled?'controlled':'uncontrolled')+\".\");ref.current=isControlled;var setValue=$11sjw$useCallback(function(value2){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var onChangeCaller=function onChangeCaller(value){if(onChange){for(var _len2=arguments.length,onChangeArgs=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){onChangeArgs[_key2-1]=arguments[_key2];}if(!Object.is(stateRef.current,value))onChange.apply(void 0,[value].concat(onChangeArgs));}if(!isControlled)stateRef.current=value;};if(typeof value2==='function'){console.warn('We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320');var updateFunction=function updateFunction(oldValue){for(var _len3=arguments.length,functionArgs=new Array(_len3>1?_len3-1:0),_key3=1;_key3<_len3;_key3++){functionArgs[_key3-1]=arguments[_key3];}var interceptedValue=value2.apply(void 0,[isControlled?stateRef.current:oldValue].concat(functionArgs));onChangeCaller.apply(void 0,[interceptedValue].concat(args));if(!isControlled)return interceptedValue;return oldValue;};setStateValue(updateFunction);}else{if(!isControlled)setStateValue(value2);onChangeCaller.apply(void 0,[value2].concat(args));}},[isControlled,onChange]);if(isControlled)stateRef.current=value1;else value1=stateValue;return[value1,setValue];}var $48d9f1d165180307$exports={};$parcel$export($48d9f1d165180307$exports,\"clamp\",function(){return $48d9f1d165180307$export$7d15b64cf5a3a4c4;});$parcel$export($48d9f1d165180307$exports,\"snapValueToStep\",function(){return $48d9f1d165180307$export$cb6e0bb50bc19463;});$parcel$export($48d9f1d165180307$exports,\"toFixedNumber\",function(){return $48d9f1d165180307$export$b6268554fba451f;});function $48d9f1d165180307$export$7d15b64cf5a3a4c4(value){var min=arguments.length>1&&arguments[1]!==undefined?arguments[1]:-Infinity;var max=arguments.length>2&&arguments[2]!==undefined?arguments[2]:Infinity;var newValue=Math.min(Math.max(value,min),max);return newValue;}function $48d9f1d165180307$export$cb6e0bb50bc19463(value,min,max,step){var remainder=(value-(isNaN(min)?0:min))%step;var snappedValue=Math.abs(remainder)*2>=step?value+Math.sign(remainder)*(step-Math.abs(remainder)):value-remainder;if(!isNaN(min)){if(snappedValue<min)snappedValue=min;else if(!isNaN(max)&&snappedValue>max)snappedValue=min+Math.floor((max-min)/step)*step;}else if(!isNaN(max)&&snappedValue>max)snappedValue=Math.floor(max/step)*step;var string=step.toString();var index=string.indexOf('.');var precision=index>=0?string.length-index:0;if(precision>0){var pow=Math.pow(10,precision);snappedValue=Math.round(snappedValue*pow)/pow;}return snappedValue;}function $48d9f1d165180307$export$b6268554fba451f(value,digits){var base=arguments.length>2&&arguments[2]!==undefined?arguments[2]:10;var pow=Math.pow(base,digits);return Math.round(value*pow)/pow;}export{$bfee1151ccb0650f$export$40bfa8c7b0832715 as useControlledState,$48d9f1d165180307$export$7d15b64cf5a3a4c4 as clamp,$48d9f1d165180307$export$cb6e0bb50bc19463 as snapValueToStep,$48d9f1d165180307$export$b6268554fba451f as toFixedNumber};","map":{"version":3,"sources":["packages/@react-stately/utils/src/useControlledState.ts","packages/@react-stately/utils/src/number.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useRef, useState} from 'react';\n\nexport function useControlledState<T>(\n  value: T,\n  defaultValue: T,\n  onChange: (value: T, ...args: any[]) => void\n): [T, (value: T, ...args: any[]) => void]  {\n  let [stateValue, setStateValue] = useState(value || defaultValue);\n  let ref = useRef(value !== undefined);\n  let wasControlled = ref.current;\n  let isControlled = value !== undefined;\n  // Internal state reference for useCallback\n  let stateRef = useRef(stateValue);\n  if (wasControlled !== isControlled) {\n    console.warn(`WARN: A component changed from ${wasControlled ? 'controlled' : 'uncontrolled'} to ${isControlled ? 'controlled' : 'uncontrolled'}.`);\n  }\n\n  ref.current = isControlled;\n\n  let setValue = useCallback((value, ...args) => {\n    let onChangeCaller = (value, ...onChangeArgs) => {\n      if (onChange) {\n        if (!Object.is(stateRef.current, value)) {\n          onChange(value, ...onChangeArgs);\n        }\n      }\n      if (!isControlled) {\n        stateRef.current = value;\n      }\n    };\n\n    if (typeof value === 'function') {\n      console.warn('We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320');\n      // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n      // when someone using useControlledState calls setControlledState(myFunc)\n      // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n      // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n      // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n      let updateFunction = (oldValue, ...functionArgs) => {\n        let interceptedValue = value(isControlled ? stateRef.current : oldValue, ...functionArgs);\n        onChangeCaller(interceptedValue, ...args);\n        if (!isControlled) {\n          return interceptedValue;\n        }\n        return oldValue;\n      };\n      setStateValue(updateFunction);\n    } else {\n      if (!isControlled) {\n        setStateValue(value);\n      }\n      onChangeCaller(value, ...args);\n    }\n  }, [isControlled, onChange]);\n\n  // If a controlled component's value prop changes, we need to update stateRef\n  if (isControlled) {\n    stateRef.current = value;\n  } else {\n    value = stateValue;\n  }\n\n  return [value, setValue];\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */\nexport function clamp(value: number, min: number = -Infinity, max: number = Infinity): number {\n  let newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\n\nexport function snapValueToStep(value: number, min: number, max: number, step: number): number {\n  let remainder = ((value - (isNaN(min) ? 0 : min)) % step);\n  let snappedValue = Math.abs(remainder) * 2 >= step\n    ? value + Math.sign(remainder) * (step - Math.abs(remainder))\n    : value - remainder;\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor((max - min) / step) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(max / step) * step;\n  }\n\n  // correct floating point behavior by rounding to step precision\n  let string = step.toString();\n  let index = string.indexOf('.');\n  let precision = index >= 0 ? string.length - index : 0;\n\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    snappedValue = Math.round(snappedValue * pow) / pow;\n  }\n\n  return snappedValue;\n}\n\n/* Takes a value and rounds off to the number of digits. */\nexport function toFixedNumber(value: number, digits: number, base: number = 10): number {\n  const pow = Math.pow(base, digits);\n\n  return Math.round(value * pow) / pow;\n}\n"]},"metadata":{},"sourceType":"module"}